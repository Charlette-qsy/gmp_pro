// This file provide a set of tools to config ti-gti tool to link to the debugger

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#define BOOL BOOL
#define GTI_NO_FUNCTION_DECLARATIONS
#include "third_party/ti_gti/headers/gti.h"

// Path and name of board config file.
// This file would be generated by the following command:
// C:\ti\ccs1281\ccs\ccs_base\common\uscif\dbgjtag.exe -f "C:\Users\javnson\AppData\Local\Texas
// Instruments\CCS\ccs1281\0\0\BrdDat\testBoard.dat" -rv -o -F inform, logfile=yes -S pathlength -S integrity
//
// This file is related to debugger and chip family
#define BOARD_FILE "C:\\Users\\javnson\\AppData\\Local\\TEXASI~1\\CCS\\ccs1281\\0\\0\\BrdDat\\ccBoard0.dat"

// File Name of the C28x series driver
// This config would be find in the following files:
//
// C:\ti\ccs1281\ccs\ccs_base\common\targetdb\drivers\tixds100v2c28x.xml
//
// This driver interface is stored in:
//
// C:\ti\ccs1281\ccs\ccs_base\emulation\drivers\tixds28x.dvr
//
#define C28X_DRIVER "tixds28x.dvr"

// Debug probe port class for xds100v3 & xds100v2
//
#define PROBE_PORT (0x240)

// User should add the following path to the system path environment variable
// C:\ti\ccs_base\common\uscif
// C:\ti\ccs_base\common\bin
// C:\ti\ccs_base\emulation\drivers
//
// Or user may call the registe environement funciton to add these path to system path environments.
#define CCS_FLODER    "C:\\ti\\ccs_base\\"
#define DRIVER_SUBDIR "emulation\\drivers\\"
#define USCIF_SUBDIR  "common\\uscif\\"
#define COMMON_SUBDIR "common\\bin\\"

// This is the standard device name
//
// #define DEVICE_NAME  "Texas Instruments XDS100v2 USB Debug Probe_0/c28xx"
#define DEVICE_NAME "Texas Instruments XDS100v3 USB Debug Probe_0/c28xx"

// CPU reg id may read from the following folders:
// C:\ti\ccs1281\ccs\ccs_base\common\targetdb\drivers\TI_reg_ids\TMS320C28XX_regids.xml
//
#define C28XX_DEVICE_REG_IDS "TMS320C28XX_regids.xml"

// Chip Setting may be found in the following folders:
// C:\ti\ccs1281\ccs\ccs_base\emulation\gel\f28035.gel

//////////////////////////////////////////////////////////////////////////
// Global Variables

// handle of Driver
HMODULE hDVR = 0;

//////////////////////////////////////////////////////////////////////////
// Functions provided by GTI
//

GTI_FN_INIT_EX *GTI_INIT_EX = 0;
GTI_FN_GEN *GTI_QUIT = 0;
GTI_FN_CONNECT *GTI_CONNECT = 0;
GTI_FN_CONNECT *GTI_CONNECT2 = 0;
GTI_FN_DISCONNECT *GTI_DISCONNECT = 0;
GTI_FN_GETERR_EX3 *GTI_GETERRSTR_EX3 = 0;

GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *GTI_GETREV = 0;
GTI_FN_QUERY_INTERFACE *GTI_QUERY_INTERFACE = 0;
GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *GTI_GETPROCTYPE = 0;
GTI_FN_GET_PROC_ID *GTI_GET_PROC_ID = 0;
GTI_FN_GET_PROC_ID *GTI_GET_PROC_MINOR_ID = 0;
GTI_FN_GET_EXT_CAPABILITIES *GTI_GET_EXT_CAPABILITIES = 0;
GTI_FN_SETUP_PROPERTIES *GTI_SETUP_PROPERTIES = 0;
GTI_FN_CONFIG_EX *GTI_CONFIG = 0;
GTI_FN_REALTIME_SWITCH *GTI_REALTIME_SWITCH = 0;
GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *GTI_GET_NON_INTRUSIVE_CAPABILITIES = 0;

GTI_FN_STAT *GTI_STAT = 0;
GTI_FN_STAT_EX2 *GTI_STAT_EX2 = 0;
GTI_FN_GET_TARGET_PROPERTIES *GTI_GET_TARGET_PROPERTIES = 0;

GTI_FN_MEM_WITH_STAT_64 *GTI_READMEM_WITH_STAT_64 = 0;
GTI_FN_MEM_WITH_STAT_64 *GTI_WRITEMEM_WITH_STAT_64 = 0;
GTI_FN_MEM_WITH_STAT *GTI_READMEM_WITH_STAT = 0;
GTI_FN_MEM_WITH_STAT *GTI_WRITEMEM_WITH_STAT = 0;
GTI_FN_MEM_EX *GTI_READMEM_EX = 0;
GTI_FN_MEM_EX *GTI_WRITEMEM_EX = 0;
GTI_FN_MEM_BLK *GTI_READMEM_BLK = 0;
GTI_FN_MEM_BLK *GTI_WRITEMEM_BLK = 0;
GTI_FN_MEM_LEVEL_INFO *GTI_GET_MEM_LEVEL_INFO = 0;

GTI_FN_REG *GTI_READREG = 0;
GTI_FN_REG *GTI_WRITEREG = 0;

GTI_FN_EXEC *GTI_HALT = 0;
GTI_FN_EXEC *GTI_RUN = 0;
GTI_FN_EXEC *GTI_STEP = 0;
GTI_FN_GLOBALSTART *GTI_GLOBALSTART = 0;
GTI_FN_RUN_EX *GTI_RUN_EX = 0;

GTI_FN_NUM_RESET *GTI_RESET_EX = 0;
GTI_FN_RESET *GTI_RESET = 0;
GTI_FN_NUM_RESET *GTI_GET_NUM_RESETS = 0;
GTI_FN_GEN_INFO *GTI_GET_RESET_INFO = 0;
GTI_FN_EMURESET_EX *GTI_EMURESET_EX = 0;
GTI_FN_SET_WAIT_IN_RESET *GTI_SET_WAIT_IN_RESET = 0;
GTI_FN_GET_WAIT_IN_RESET_MODE *GTI_GET_WAIT_IN_RESET_MODE = 0;
GTI_FN_BLOCK_RESET *GTI_BLOCK_RESET = 0;

//////////////////////////////////////////////////////////////////////////
// Register path variables
//
void reg_system_path()
{
    // Set up PATH environment variable to locate the GTI API libraries
    const int MAX_ENV_VAR = 8191;   // Max length for command line parameters
    char *oldPath = getenv("PATH"); // Retrieve the current PATH environment variable
    char newPath[MAX_ENV_VAR + 1];  // Allocate space for the updated PATH

    // Begin the set PATH with the USCIF, common, and drivers paths.
    strncpy(newPath, "PATH=" CCS_FLODER USCIF_SUBDIR ";" CCS_FLODER COMMON_SUBDIR ";" CCS_FLODER DRIVER_SUBDIR ";",
            MAX_ENV_VAR);

    // Append the old PATH environment variable.
    strncat(newPath, oldPath, MAX_ENV_VAR);
    newPath[MAX_ENV_VAR] = 0;

    // Apply the change (affects only this process).
    putenv(newPath);
}

//////////////////////////////////////////////////////////////////////////
// Load all GTI functions
//
int init_gti_librarys()
{
    // return
    bool success = true;

    if (hDVR != 0)
    {
        printf("The GTI Library has been loaded.\r\n");
        return 0;
    }

    // Load the emulation driver into memory.
    hDVR = LoadLibrary(C28X_DRIVER);

    if (0 == hDVR)
    {
        // The driver or a dependent library failed to load
        success = false;
        printf("Failed to load the emulation driver.\r\n");
    }
    else
    {
        printf("TI-GTI: %s driver has loaded.\r\n", C28X_DRIVER);
    }

    if (success)
    {
        // Load the GTI API calls from the driver library
        //

        // ....................................................................... //
        // MAIN function

        // Initialize the debug session.
        GTI_INIT_EX = (GTI_FN_INIT_EX *)GetProcAddress(hDVR, "GTI_INIT_EX");
        // Terminate the debug session.
        GTI_QUIT = (GTI_FN_GEN *)GetProcAddress(hDVR, "GTI_QUIT");
        // Connect to target.
        GTI_CONNECT = (GTI_FN_CONNECT *)GetProcAddress(hDVR, "GTI_CONNECT");
        // Connect to target non-intrusively.
        GTI_CONNECT2 = (GTI_FN_CONNECT *)GetProcAddress(hDVR, "GTI_CONNECT2");
        // Disconnect from target.
        GTI_DISCONNECT = (GTI_FN_DISCONNECT *)GetProcAddress(hDVR, "GTI_DISCONNECT");

        if (GTI_INIT_EX == 0 || GTI_QUIT == 0 || GTI_CONNECT == 0 || GTI_CONNECT2 == 0 || GTI_DISCONNECT == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. MAIN function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TI-GTI MAIN function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // CONFIG functions

        // Retrieve the GTI API revision of driver.
        GTI_GETREV = (GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *)GetProcAddress(hDVR, "GTI_GETREV");
        // Query for additional GTI features.
        GTI_QUERY_INTERFACE = (GTI_FN_QUERY_INTERFACE *)GetProcAddress(hDVR, "GTI_FN_QUERY_INTERFACE");
        // Get device type of device driver.
        GTI_GETPROCTYPE = (GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *)GetProcAddress(hDVR, "GTI_GETPROCTYPE");
        // Get Proc ID of target device.
        GTI_GET_PROC_ID = (GTI_FN_GET_PROC_ID *)GetProcAddress(hDVR, "GTI_GET_PROC_ID");
        // Get minor revision of target device.
        GTI_GET_PROC_MINOR_ID = (GTI_FN_GET_PROC_ID *)GetProcAddress(hDVR, "GTI_GET_PROC_MINOR_ID");
        // Gets the supported features of the driver.
        GTI_GET_EXT_CAPABILITIES = (GTI_FN_GET_EXT_CAPABILITIES *)GetProcAddress(hDVR, "GTI_GET_EXT_CAPABILITIES");
        // Sets the configuration parameters of the driver.
        GTI_SETUP_PROPERTIES = (GTI_FN_SETUP_PROPERTIES *)GetProcAddress(hDVR, "GTI_SETUP_PROPERTIES");
        // Controls getting and setting configuration parameters.
        GTI_CONFIG = (GTI_FN_CONFIG_EX *)GetProcAddress(hDVR, "GTI_CONFIG");

        // TRG REALTIME CONFIG functions

        // Controls real-time mode setting.
        GTI_REALTIME_SWITCH = (GTI_FN_REALTIME_SWITCH *)GetProcAddress(hDVR, "GTI_REALTIME_SWITCH");
        // Gets the non-intrusive features of the driver.
        GTI_GET_NON_INTRUSIVE_CAPABILITIES =
            (GTI_FN_GET_NON_INTRUSIVE_CAPABILITIES *)GetProcAddress(hDVR, "GTI_GET_NON_INTRUSIVE_CAPABILITIES");

        if (GTI_GETREV == 0 || GTI_QUERY_INTERFACE == 0 || GTI_GETPROCTYPE == 0 || GTI_GET_PROC_ID == 0 ||
            GTI_GET_PROC_MINOR_ID == 0 || GTI_GET_EXT_CAPABILITIES == 0 || GTI_SETUP_PROPERTIES == 0 || GTI_CONFIG == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. CONFIG function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI CONFIG function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // ERROR functions

        // Return pending error message from the driver.
        GTI_GETERRSTR_EX3 = (GTI_FN_GETERR_EX3 *)GetProcAddress(hDVR, "GTI_GETERRSTR_EX3");

        // ....................................................................... //
        // STATUS functions

        // Retrieve current status of the target device.
        GTI_STAT = (GTI_FN_STAT *)GetProcAddress(hDVR, "GTI_STAT");
        // Retrieve extended status of the target device.
        GTI_STAT_EX2 = (GTI_FN_STAT_EX2 *)GetProcAddress(hDVR, "GTI_STAT_EX2");
        // Retrieve properties of the target device.
        GTI_GET_TARGET_PROPERTIES = (GTI_FN_GET_TARGET_PROPERTIES *)GetProcAddress(hDVR, "GTI_GET_TARGET_PROPERTIES");

        if (GTI_GETERRSTR_EX3 == 0 || GTI_STAT == 0 || GTI_STAT_EX2 == 0 || GTI_GET_TARGET_PROPERTIES == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. ERROR&STATUS function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI ERROR&STATUS function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // MEMORY functions

        // Read target memory with 64-bit memory addresses.
        GTI_READMEM_WITH_STAT_64 = (GTI_FN_MEM_WITH_STAT_64 *)GetProcAddress(hDVR, "GTI_READMEM_WITH_STAT_64");
        // Write target memory with 64-bit memory addresses.
        GTI_WRITEMEM_WITH_STAT_64 = (GTI_FN_MEM_WITH_STAT_64 *)GetProcAddress(hDVR, "GTI_WRITEMEM_WITH_STAT_64");
        // Read target memory with status.
        GTI_READMEM_WITH_STAT = (GTI_FN_MEM_WITH_STAT *)GetProcAddress(hDVR, "GTI_READMEM_WITH_STAT");
        // Write target memory with status.
        GTI_WRITEMEM_WITH_STAT = (GTI_FN_MEM_WITH_STAT *)GetProcAddress(hDVR, "GTI_WRITEMEM_WITH_STAT");
        // Read target memory.
        GTI_READMEM_EX = (GTI_FN_MEM_EX *)GetProcAddress(hDVR, "GTI_READMEM_EX");
        // Write target memory.
        GTI_WRITEMEM_EX = (GTI_FN_MEM_EX *)GetProcAddress(hDVR, "GTI_WRITEMEM_EX");
        // Read target memory with access size.
        GTI_READMEM_BLK = (GTI_FN_MEM_BLK *)GetProcAddress(hDVR, "GTI_READMEM_BLK");
        // Write target memory with access size.
        GTI_WRITEMEM_BLK = (GTI_FN_MEM_BLK *)GetProcAddress(hDVR, "GTI_WRITEMEM_BLK");
        // Query for memory level definitions.
        GTI_GET_MEM_LEVEL_INFO = (GTI_FN_MEM_LEVEL_INFO *)GetProcAddress(hDVR, "GTI_GET_MEM_LEVEL_INFO");

        if (GTI_READMEM_WITH_STAT_64 == 0 || GTI_WRITEMEM_WITH_STAT_64 == 0 || GTI_READMEM_WITH_STAT == 0 ||
            GTI_WRITEMEM_WITH_STAT == 0 || GTI_READMEM_EX == 0 || GTI_WRITEMEM_EX == 0 || GTI_READMEM_BLK == 0 ||
            GTI_WRITEMEM_BLK == 0 || GTI_GET_MEM_LEVEL_INFO == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. MEMORY function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI MEMORY function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // REGISTER functions

        // Read target register.
        GTI_READREG = (GTI_FN_REG *)GetProcAddress(hDVR, "GTI_READREG");
        // Write to target register.
        GTI_WRITEREG = (GTI_FN_REG *)GetProcAddress(hDVR, "GTI_WRITEREG");

        if (GTI_READREG == 0 || GTI_WRITEREG == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. REGISTER function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI REGISTER function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // EXECUTION functions

        // Halt target device.
        GTI_HALT = (GTI_FN_EXEC *)GetProcAddress(hDVR, "GTI_HALT");
        // Run target device.
        GTI_RUN = (GTI_FN_EXEC *)GetProcAddress(hDVR, "GTI_RUN");
        // Single step target device.
        GTI_STEP = (GTI_FN_EXEC *)GetProcAddress(hDVR, "GTI_STEP");
        // Run target device for a number of instructions.
        GTI_RUN_EX = (GTI_FN_RUN_EX *)GetProcAddress(hDVR, "GTI_RUN_EX");
        // Start a synchronous run.
        GTI_GLOBALSTART = (GTI_FN_GLOBALSTART *)GetProcAddress(hDVR, "GTI_GLOBALSTART");

        if (GTI_HALT == 0 || GTI_RUN == 0 || GTI_STEP == 0 || GTI_RUN_EX == 0 || GTI_GLOBALSTART == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. EXECUTION function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI EXECUTION function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // RESET functions

        // Reset target device.
        GTI_RESET_EX = (GTI_FN_NUM_RESET *)GetProcAddress(hDVR, "GTI_RESET_EX");
        // Reset target device.
        GTI_RESET = (GTI_FN_RESET *)GetProcAddress(hDVR, "GTI_RESET");
        // Get number of reset types available for this device.
        GTI_GET_NUM_RESETS = (GTI_FN_NUM_RESET *)GetProcAddress(hDVR, "GTI_GET_NUM_RESETS");
        // Get details for each available reset type.
        GTI_GET_RESET_INFO = (GTI_FN_GEN_INFO *)GetProcAddress(hDVR, "GTI_GET_RESET_INFO");
        // Set the wait-in-reset (WIR) mode.
        GTI_SET_WAIT_IN_RESET = (GTI_FN_EMURESET_EX *)GetProcAddress(hDVR, "GTI_SET_WAIT_IN_RESET");
        // Get the wait-in-reset (WIR) mode.
        GTI_GET_WAIT_IN_RESET_MODE = (GTI_FN_SET_WAIT_IN_RESET *)GetProcAddress(hDVR, "GTI_GET_WAIT_IN_RESET_MODE");
        // Set the block reset mode.
        GTI_BLOCK_RESET = (GTI_FN_BLOCK_RESET *)GetProcAddress(hDVR, "GTI_BLOCK_RESET");

        if (GTI_RESET_EX == 0 || GTI_RESET == 0 || GTI_GET_NUM_RESETS == 0 || GTI_GET_RESET_INFO == 0 ||
            GTI_SET_WAIT_IN_RESET == 0 || GTI_GET_WAIT_IN_RESET_MODE == 0 || GTI_BLOCK_RESET == 0)
        {
            success = false;
            printf("TI-GTI Library load failed. RESET function cannot loaded correctly.\r\n");
        }
        else
        {
            printf("TO-GTI RESET function has been loaded.\r\n");
        }
    }

    if (success)
    {
        // ....................................................................... //
        // RESET functions

        GTI_FN_BP_EX *GTI_SETBP_EX = 0;
        GTI_FN_BP_EX *GTI_CLEARBP_EX = 0;
        GTI_FN_BP *GTI_SETBP = 0;
        GTI_FN_BP *GTI_CLEARBP = 0;
        GTI_FN_BP_RESET *GTI_DONE_REMOVING_DEBUG_STATE = 0;
        GTI_FN_BP_TEST *GTI_BP_TEST = 0;
    }

    // ....................................................................... //
    // Check if it's necessary to release the library
    if (success == false)
    {
        if (hDVR != 0)
        {
            FreeLibrary(hDVR);
            hDVR = 0;
            printf("Emulator Driver has been released.\r\n");
        }

        return -1;
    }

    // Initialize the emulation driver.
    GTI_INIT_INFO initInfo; // Initialization parameters structure

    memset(&initInfo, 0, sizeof(initInfo));

    initInfo.m_structRevision = GTI_INIT_INFO_REV; // Structure revision
    initInfo.m_structLength = sizeof(initInfo);    // Size of structure
    initInfo.m_sProcDataFileLocation = BOARD_FILE; // Board config file

    // GTI_EXPORT GTI_RETURN_TYPE
    //	GTI_INIT_EX(
    //		GTI_PID_TYPE     procNum,        /**< [in]  Processor number (unused). */
    //		GTI_STRING_TYPE  pathName,       /**< [in]  Session name / cpu name. */
    //		GTI_PORT_TYPE    portAddress,    /**< [in]  Debug probe port address. */
    //		GTI_STRING_TYPE  parmFileName,   /**< [in]  Path and name of board config file. */
    //		GTI_PORT_TYPE    portAddress2,   /**< [in]  Alternate debug probe port address (unused). */
    //		GTI_DMA_TYPE     dmaAddress,     /**< [in]  Debug probe DMA address (unused). */
    //		GTI_IRQ_TYPE     irq,            /**< [in]  Debug probe IRQ number (unused). */
    //		GTI_INIT_INFO * additionalInfo, /**< [in]  Additional setup information. */
    //		GTI_HANDLE_TYPE * hpid            /**< [out] GTI API instance handle. */
    //	);

    result = GTI_INIT_EX(0,           // unused
                         DEVICE_NAME, // Name of board, ends with slash and name of device to debug
                         PROBE_PORT,  // Debug probe port address (Spectrum Digital)
                         BOARD_FILE,  // Board config file
                         0,           // unused
                         0,           // unused
                         0,           // unused
                         &initInfo,   // Initialization parameters structure
                         &hpid);      // Pointer to return instance handle

    if (GTI_SUCCESS != result)
    {
        // Init call failed
        success = false;
        printf("Failed to initialize emulation driver.\n");
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
// Get GTI Error Code and informations
//
const char *GetError(GTI_HANDLE_TYPE hpid)
{
    GTI_INT_TYPE result;
    GTI_INT_TYPE sequenceId;
    GTI_INT_TYPE errorCode;
    GTI_UINT32_TYPE errorClass;
    GTI_UINT32_TYPE severity;
    GTI_UINT32_TYPE action;
    GTI_UINT32_TYPE buttons;
    GTI_UINT32_TYPE icon;
    char customButtons[64 + 1];
    GTI_STRING_TYPE pszCustomButtons = customButtons;
    GTI_UINT32_TYPE customButtonsLength = 64;
    static char errorMessage[1024 + 1];
    GTI_STRING_TYPE pszErrorMessage = errorMessage;
    GTI_UINT32_TYPE errorMessageLength = 1024;

    // Only errorMessage is used here. The other fields are used by CCS to
    // determine how the error should be treated (such as severity) and what
    // buttons are put onto the error dialog pop-up.

    result = GTI_GETERRSTR_EX3(hpid, &sequenceId, &errorCode, &errorClass, &severity, &action, &buttons, &icon,
                               pszCustomButtons, customButtonsLength, pszErrorMessage, errorMessageLength);

    return errorMessage;
}
